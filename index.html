<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tài Xỉu Prediction Tool</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    /* Reset & Globals */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    :root {
      /* Main Colors */
      --primary: #6a11cb;
      --secondary: #4e4376;
      --light: #ffffff;
      --dark: #212121;
      --gray-100: #f8f9fa;
      --gray-200: #e9ecef;
      --gray-300: #dee2e6;
      --gray-400: #ced4da;
      --gray-500: #adb5bd;
      --gray-600: #6c757d;
      --gray-700: #495057;
      --gray-800: #343a40;
      --gray-900: #212529;
      
      /* Tai Xiu Colors */
      --tai-color: #ff416c;
      --xiu-color: #1e272e;
      
      /* Spacing */
      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-5: 1.5rem;
      --space-6: 2rem;
      --space-8: 3rem;
      --space-10: 4rem;
      
      /* UI */
      --radius: 0.5rem;
      --radius-lg: 1rem;
      --radius-full: 9999px;
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 8px 16px rgba(0, 0, 0, 0.1);
    }
    
    body {
      font-family: 'Montserrat', sans-serif;
      line-height: 1.6;
      color: var(--dark);
      background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
      min-height: 100vh;
    }
    
    /* Typography */
    h1, h2, h3, h4, h5, h6 {
      margin: 0 0 var(--space-4) 0;
      font-weight: 700;
      line-height: 1.3;
    }
    
    h1 {
      font-size: 2.5rem;
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      color: transparent;
    }
    
    h2 {
      font-size: 1.75rem;
      color: var(--primary);
    }
    
    h3 {
      font-size: 1.5rem;
      color: var(--secondary);
    }
    
    h4 {
      font-size: 1.25rem;
    }
    
    p {
      margin-bottom: var(--space-4);
    }
    
    /* Layout */
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 var(--space-4);
    }
    
    .app-wrapper {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    .header {
      background: var(--light);
      box-shadow: var(--shadow);
      padding: var(--space-4) 0;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .main {
      flex: 1;
      padding: var(--space-6) 0;
    }
    
    .footer {
      background: var(--gray-800);
      color: var(--gray-400);
      padding: var(--space-5) 0;
      text-align: center;
    }
    
    /* Grid System */
    .row {
      display: flex;
      flex-wrap: wrap;
      margin: 0 calc(-1 * var(--space-4));
    }
    
    .col {
      padding: 0 var(--space-4);
      flex: 1;
    }
    
    .col-4 {
      width: 100%;
    }
    
    .col-8 {
      width: 100%;
    }
    
    @media (min-width: 992px) {
      .col-4 {
        width: 33.333333%;
      }
      
      .col-8 {
        width: 66.666667%;
      }
    }
    
    /* Cards */
    .card {
      background: var(--light);
      border-radius: var(--radius);
      box-shadow: var(--shadow-md);
      overflow: hidden;
      margin-bottom: var(--space-5);
      transition: all 0.3s ease;
      border: 1px solid var(--gray-200);
    }
    
    .card:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-md);
    }
    
    .card-header {
      padding: var(--space-4) var(--space-5);
      border-bottom: 1px solid var(--gray-200);
      background: var(--gray-100);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .card-body {
      padding: var(--space-5);
    }
    
    .card-footer {
      padding: var(--space-4) var(--space-5);
      border-top: 1px solid var(--gray-200);
      background: var(--gray-100);
    }
    
    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      text-align: center;
      vertical-align: middle;
      user-select: none;
      padding: var(--space-3) var(--space-5);
      font-size: 1rem;
      line-height: 1.5;
      border-radius: var(--radius);
      transition: all 0.3s ease;
      border: none;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
    }
    
    .btn:hover::before {
      transform: translateX(0);
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      color: var(--light);
      box-shadow: 0 4px 15px rgba(106, 17, 203, 0.4);
    }
    
    .btn-primary:hover {
      box-shadow: 0 7px 15px rgba(106, 17, 203, 0.5);
      transform: translateY(-2px);
    }
    
    .btn-secondary {
      background: linear-gradient(135deg, #2b5876 0%, #4e4376 100%);
      color: var(--light);
      box-shadow: 0 4px 15px rgba(46, 67, 118, 0.4);
    }
    
    .btn-secondary:hover {
      box-shadow: 0 7px 15px rgba(46, 67, 118, 0.5);
      transform: translateY(-2px);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, #eb3941 0%, #f15e64 100%);
      color: var(--light);
      box-shadow: 0 4px 15px rgba(235, 57, 65, 0.4);
    }
    
    .btn-danger:hover {
      box-shadow: 0 7px 15px rgba(235, 57, 65, 0.5);
      transform: translateY(-2px);
    }
    
    .btn-block {
      display: block;
      width: 100%;
    }
    
    /* Custom Tai Xiu Components */
    .result-buttons {
      display: flex;
      gap: var(--space-4);
      margin-bottom: var(--space-5);
    }
    
    .result-btn {
      font-size: 1.75rem;
      font-weight: 800;
      padding: var(--space-5) var(--space-4);
      border-radius: var(--radius-lg);
      width: 100%;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      z-index: 1;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      letter-spacing: 1px;
    }
    
    .result-btn::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 50%;
      background: rgba(0, 0, 0, 0.1);
      z-index: -1;
      transition: height 0.3s ease;
    }
    
    .result-btn:hover {
      transform: translateY(-5px);
    }
    
    .result-btn:hover::after {
      height: 100%;
    }
    
    .result-btn:active {
      transform: translateY(2px);
    }
    
    .tai-btn {
      background: linear-gradient(135deg, #ff4b2b 0%, #ff416c 100%);
      color: var(--light);
      box-shadow: 0 8px 25px rgba(255, 65, 108, 0.5);
    }
    
    .xiu-btn {
      background: linear-gradient(135deg, #1e272e 0%, #485460 100%);
      color: var(--light);
      box-shadow: 0 8px 25px rgba(30, 39, 46, 0.5);
    }
    
    .sequence-display {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
      margin-bottom: var(--space-5);
      padding: var(--space-4);
      background: var(--gray-100);
      border-radius: var(--radius);
      min-height: 6rem;
      border: 1px solid var(--gray-200);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .sequence-item {
      width: 45px;
      height: 45px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      border-radius: var(--radius-full);
      color: var(--light);
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
    }
    
    .sequence-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0) 70%);
    }
    
    .sequence-item:hover {
      transform: scale(1.15) rotate(5deg);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
      z-index: 10;
    }
    
    .sequence-item.T {
      background: linear-gradient(135deg, #ff4b2b 0%, #ff416c 100%);
    }
    
    .sequence-item.X {
      background: linear-gradient(135deg, #1e272e 0%, #485460 100%);
    }
    
    .prediction-display {
      padding: var(--space-5);
      border-radius: var(--radius);
      background: linear-gradient(135deg, var(--gray-100) 0%, var(--gray-200) 100%);
      margin-bottom: var(--space-5);
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow);
      border: 1px solid var(--gray-300);
      position: relative;
      overflow: hidden;
    }
    
    .prediction-display::before {
      content: '';
      position: absolute;
      width: 150px;
      height: 150px;
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      border-radius: var(--radius-full);
      opacity: 0.1;
      top: -75px;
      right: -75px;
    }
    
    .prediction-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-3);
    }
    
    .prediction-label {
      font-size: 1rem;
      color: var(--gray-600);
      font-weight: 500;
    }
    
    .prediction-result {
      font-size: 1.75rem;
      font-weight: 800;
      text-transform: uppercase;
      margin-bottom: var(--space-3);
      letter-spacing: 1px;
      position: relative;
      display: inline-block;
    }
    
    .prediction-result.tai {
      background: linear-gradient(135deg, #ff4b2b 0%, #ff416c 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      color: transparent;
    }
    
    .prediction-result.xiu {
      background: linear-gradient(135deg, #1e272e 0%, #485460 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      color: transparent;
    }
    
    .prediction-confidence {
      font-size: 1rem;
      color: var(--gray-700);
      font-weight: 600;
      margin-bottom: var(--space-2);
    }
    
    .confidence-bar {
      width: 100%;
      height: 10px;
      background-color: var(--gray-300);
      border-radius: var(--radius-full);
      overflow: hidden;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    
    .confidence-fill {
      height: 100%;
      border-radius: var(--radius-full);
      transition: width 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      position: relative;
    }
    
    .confidence-fill::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(255, 255, 255, 0) 0%, 
        rgba(255, 255, 255, 0.4) 50%, 
        rgba(255, 255, 255, 0) 100%);
      animation: shimmer 2s infinite;
    }
    
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    /* Stats display */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: var(--space-4);
      margin-bottom: var(--space-5);
    }
    
    .stat-item {
      background: var(--light);
      padding: var(--space-4);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      text-align: center;
      transition: all 0.3s ease;
      border: 1px solid var(--gray-200);
      position: relative;
      overflow: hidden;
    }
    
    .stat-item::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 4px;
      top: 0;
      left: 0;
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
    }
    
    .stat-item:hover {
      transform: translateY(-5px);
      box-shadow: var(--shadow-md);
    }
    
    .stat-value {
      font-size: 2rem;
      font-weight: 800;
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      color: transparent;
      line-height: 1.2;
      margin-bottom: var(--space-2);
    }
    
    .stat-label {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--gray-600);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      list-style: none;
      border-bottom: 2px solid var(--gray-200);
      margin-bottom: var(--space-5);
      overflow-x: auto;
      scrollbar-width: none;
    }
    
    .tabs::-webkit-scrollbar {
      display: none;
    }
    
    .tab-item {
      padding: var(--space-3) var(--space-4);
      font-weight: 600;
      color: var(--gray-600);
      cursor: pointer;
      position: relative;
      transition: all 0.3s ease;
      white-space: nowrap;
    }
    
    .tab-item::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 0;
      height: 3px;
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      transition: width 0.3s ease;
    }
    
    .tab-item:hover {
      color: var(--primary);
    }
    
    .tab-item:hover::after {
      width: 100%;
    }
    
    .tab-item.active {
      color: var(--primary);
    }
    
    .tab-item.active::after {
      width: 100%;
    }
    
    .tab-content {
      display: none;
      animation: fadeIn 0.5s ease;
    }
    
    .tab-content.active {
      display: block;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Chart styles */
    .chart-container {
      width: 100%;
      height: 300px;
      margin-bottom: var(--space-5);
      background: var(--light);
      border-radius: var(--radius);
      padding: var(--space-4);
      box-shadow: var(--shadow);
      position: relative;
      border: 1px solid var(--gray-200);
      overflow: hidden;
    }
    
    .chart-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.125rem;
      color: var(--gray-500);
      text-align: center;
      padding: var(--space-5);
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(3px);
    }
    
    /* Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
      backdrop-filter: blur(5px);
    }
    
    .modal.show {
      opacity: 1;
      visibility: visible;
    }
    
    .modal-content {
      background: var(--light);
      border-radius: var(--radius-lg);
      max-width: 90%;
      width: 850px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: var(--shadow-md);
      transform: scale(0.95);
      transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      border: 1px solid var(--gray-200);
    }
    
    .modal.show .modal-content {
      transform: scale(1);
    }
    
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-4) var(--space-5);
      border-bottom: 1px solid var(--gray-200);
      background: linear-gradient(135deg, var(--gray-100) 0%, var(--light) 100%);
    }
    
    .modal-title {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      color: transparent;
    }
    
    .modal-close {
      background: none;
      border: none;
      font-size: 1.75rem;
      cursor: pointer;
      color: var(--gray-500);
      transition: all 0.3s ease;
      width: 40px;
      height: 40px;
      border-radius: var(--radius-full);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .modal-close:hover {
      color: #eb3941;
      background: rgba(235, 57, 65, 0.1);
      transform: rotate(90deg);
    }
    
    .modal-body {
      padding: var(--space-5);
    }
    
    /* Loading indicator */
    .loading-indicator {
      display: inline-block;
      width: 2rem;
      height: 2rem;
      position: relative;
    }
    
    .loading-indicator:before,
    .loading-indicator:after {
      content: '';
      position: absolute;
      border-radius: var(--radius-full);
      animation: pulse 2s linear infinite;
    }
    
    .loading-indicator:before {
      width: 100%;
      height: 100%;
      background: #8844e0;
      animation-delay: 0.25s;
    }
    
    .loading-indicator:after {
      width: 75%;
      height: 75%;
      background: var(--primary);
      top: 12.5%;
      left: 12.5%;
      animation-delay: 0s;
    }
    
    @keyframes pulse {
      0% { transform: scale(0.95); opacity: 0.8; }
      50% { transform: scale(1.05); opacity: 0.5; }
      100% { transform: scale(0.95); opacity: 0.8; }
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .row {
        flex-direction: column;
      }
      
      .col, .col-4, .col-8 {
        width: 100%;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      h2 {
        font-size: 1.5rem;
      }
      
      .result-btn {
        font-size: 1.5rem;
        padding: var(--space-4) var(--space-3);
      }
      
      .sequence-item {
        width: 38px;
        height: 38px;
        font-size: 0.9rem;
      }
      
      .stats-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }
      
      .stat-value {
        font-size: 1.5rem;
      }
      
      .tab-item {
        padding: var(--space-2) var(--space-3);
        font-size: 0.9rem;
      }
    }
    
    /* Utility Classes */
    .text-center { text-align: center; }
    .text-right { text-align: right; }
    .text-left { text-align: left; }
    
    .mt-1 { margin-top: var(--space-1); }
    .mt-2 { margin-top: var(--space-2); }
    .mt-3 { margin-top: var(--space-3); }
    .mt-4 { margin-top: var(--space-4); }
    .mt-5 { margin-top: var(--space-5); }
    
    .mb-1 { margin-bottom: var(--space-1); }
    .mb-2 { margin-bottom: var(--space-2); }
    .mb-3 { margin-bottom: var(--space-3); }
    .mb-4 { margin-bottom: var(--space-4); }
    .mb-5 { margin-bottom: var(--space-5); }
    
    .mx-auto { margin-left: auto; margin-right: auto; }
    
    .d-flex { display: flex; }
    .justify-content-between { justify-content: space-between; }
    .align-items-center { align-items: center; }
    
    .w-100 { width: 100%; }
    .h-100 { height: 100%; }
  </style>
</head>
<body>
  <div class="app-wrapper">
    <header class="header">
      <div class="container">
        <div class="header-content">
          <h1>Tài Xỉu Prediction Tool</h1>
          <div class="d-flex align-items-center">
            <div style="color: var(--primary); font-weight: 600;">Phiên bản 2.0</div>
          </div>
        </div>
      </div>
    </header>
    
    <main class="main">
      <div class="container">
        <div class="row">
          <div class="col col-4">
            <!-- Sequence Input -->
            <div class="card">
              <div class="card-header">
                <h2>Nhập kết quả</h2>
                <div class="loading-indicator" id="loading-indicator" style="display: none;"></div>
              </div>
              <div class="card-body">
                <div class="result-buttons">
                  <button id="tai-btn" class="btn result-btn tai-btn">TÀI</button>
                  <button id="xiu-btn" class="btn result-btn xiu-btn">XỈU</button>
                </div>
                
                <div class="sequence-display" id="sequence-display">
                  <!-- Sequence items will be displayed here -->
                </div>
                
                <div class="d-flex justify-content-between mb-4">
                  <button id="delete-last" class="btn btn-secondary">
                    <span>Xóa kết quả cuối</span>
                  </button>
                  <button id="clear-all" class="btn btn-danger">
                    <span>Xóa tất cả</span>
                  </button>
                </div>
                
                <div class="prediction-display" id="prediction-display">
                  <div class="prediction-header">
                    <div class="prediction-label">Dự đoán kết quả tiếp theo</div>
                  </div>
                  <div class="prediction-result" id="prediction-value">--</div>
                  <div class="prediction-confidence">Độ tin cậy: <span id="confidence-value">--</span></div>
                  <div class="confidence-bar">
                    <div class="confidence-fill" id="confidence-bar" style="width: 0%;"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="col col-8">
            <!-- Result Analysis -->
            <div class="card">
              <div class="card-header">
                <h2>Phân tích kết quả</h2>
              </div>
              <div class="card-body">
                <ul class="tabs" id="analysis-tabs">
                  <li class="tab-item active" data-tab="prediction">Dự đoán</li>
                  <li class="tab-item" data-tab="patterns">Mẫu</li>
                  <li class="tab-item" data-tab="statistics">Thống kê</li>
                  <li class="tab-item" data-tab="cauanalysis">Phân tích cầu</li>
                  <li class="tab-item" data-tab="tips">Mẹo</li>
                </ul>
                
                <div id="tab-prediction" class="tab-content active">
                  <h3>Dự đoán kết quả tiếp theo</h3>
                  <p>Hệ thống sử dụng thuật toán AI tiên tiến để phân tích và dự đoán kết quả Tài Xỉu tiếp theo với độ chính xác cao.</p>
                  
                  <div class="stats-grid">
                    <div class="stat-item">
                      <div class="stat-value" id="stat-accuracy">--</div>
                      <div class="stat-label">Độ chính xác</div>
                    </div>
                    <div class="stat-item">
                      <div class="stat-value" id="stat-total">0</div>
                      <div class="stat-label">Tổng số kết quả</div>
                    </div>
                    <div class="stat-item">
                      <div class="stat-value" id="stat-tai-ratio">--</div>
                      <div class="stat-label">Tỷ lệ Tài</div>
                    </div>
                    <div class="stat-item">
                      <div class="stat-value" id="stat-xiu-ratio">--</div>
                      <div class="stat-label">Tỷ lệ Xỉu</div>
                    </div>
                  </div>
                  
                  <h3>Mô hình dự đoán</h3>
                  <p>Thuật toán dự đoán phân tích dựa trên:</p>
                  <ul style="padding-left: 1.5rem; margin-bottom: var(--space-4);">
                    <li><strong>Phân tích cầu:</strong> Nhận diện mẫu cầu và điểm bẻ cầu tối ưu</li>
                    <li><strong>Mô hình Fibonacci:</strong> Phân tích dựa trên dãy số Fibonacci (1, 2, 3, 5, 8, 13)</li>
                    <li><strong>Thuật toán tỉ lệ vàng:</strong> Phân tích dựa trên hệ số phi (1.618...)</li>
                    <li><strong>Ensemble Learning:</strong> Kết hợp nhiều mô hình dự đoán cho kết quả chính xác nhất</li>
                  </ul>
                  
                  <div class="chart-container">
                    <div id="prediction-chart" class="chart"></div>
                    <div class="chart-placeholder">Nhập ít nhất 5 kết quả để hiển thị biểu đồ</div>
                  </div>
                </div>
                
                <div id="tab-patterns" class="tab-content">
                  <h3>Phân tích mẫu</h3>
                  <p>Hệ thống phát hiện các mẫu lặp lại trong chuỗi kết quả.</p>
                  
                  <div id="pattern-details" class="mb-4">
                    <h4>Mẫu đã phát hiện:</h4>
                    <div id="pattern-description" class="py-3 px-4 bg-gray rounded">Chưa có đủ dữ liệu để phân tích mẫu.</div>
                  </div>
                  
                  <div class="chart-container">
                    <div id="pattern-chart" class="chart"></div>
                    <div class="chart-placeholder">Nhập ít nhất 5 kết quả để hiển thị biểu đồ</div>
                  </div>
                  
                  <div id="pattern-recommendation" class="mb-4 mt-5">
                    <h4>Khuyến nghị:</h4>
                    <div id="recommendation-text" class="py-3 px-4 bg-gray rounded">Chưa có đủ dữ liệu để đưa ra khuyến nghị.</div>
                  </div>
                </div>
                
                <div id="tab-statistics" class="tab-content">
                  <h3>Thống kê</h3>
                  
                  <div class="stats-grid">
                    <div class="stat-item">
                      <div class="stat-value" id="stat-tai-count">0</div>
                      <div class="stat-label">Số lần Tài</div>
                    </div>
                    <div class="stat-item">
                      <div class="stat-value" id="stat-xiu-count">0</div>
                      <div class="stat-label">Số lần Xỉu</div>
                    </div>
                    <div class="stat-item">
                      <div class="stat-value" id="stat-longest-streak">0</div>
                      <div class="stat-label">Chuỗi dài nhất</div>
                    </div>
                    <div class="stat-item">
                      <div class="stat-value" id="stat-current-streak">0</div>
                      <div class="stat-label">Chuỗi hiện tại</div>
                    </div>
                  </div>
                  
                  <div class="chart-container">
                    <div id="distribution-chart" class="chart"></div>
                    <div class="chart-placeholder">Nhập ít nhất 5 kết quả để hiển thị biểu đồ</div>
                  </div>
                  
                  <button id="show-chart-modal" class="btn btn-primary">Xem thêm biểu đồ</button>
                </div>
                
                <div id="tab-cauanalysis" class="tab-content">
                  <h3>Phân tích cầu</h3>
                  <p>Phân tích chuyên sâu về cầu hiện tại và khả năng bẻ cầu.</p>
                  
                  <div id="cau-analysis-result" class="mb-4 mt-3">
                    <h4>Kết quả phân tích:</h4>
                    <div id="cau-details" class="py-3 px-4 bg-gray rounded">Chưa có đủ dữ liệu để phân tích cầu.</div>
                  </div>
                  
                  <div class="chart-container">
                    <div id="cau-chart" class="chart"></div>
                    <div class="chart-placeholder">Nhập ít nhất 5 kết quả để hiển thị biểu đồ</div>
                  </div>
                  
                  <div id="breakpoint-analysis" class="mb-4 mt-5">
                    <h4>Phân tích bẻ cầu:</h4>
                    <div id="breakpoint-details" class="py-3 px-4 bg-gray rounded">Chưa có đủ dữ liệu để phân tích bẻ cầu.</div>
                  </div>
                </div>
                
                <div id="tab-tips" class="tab-content">
                  <h3>Mẹo và chiến thuật</h3>
                  
                  <div class="mb-4">
                    <h4 class="d-flex align-items-center">
                      <span style="width: 28px; height: 28px; color: white; background: var(--primary); border-radius: 50%; display: flex; justify-content: center; align-items: center; margin-right: 8px;">1</span>
                      Chiến thuật theo cầu
                    </h4>
                    <div class="py-3 px-4 bg-gray rounded mt-2">
                      Theo dõi và đặt theo cầu khi cầu còn ngắn (1-3 kết quả giống nhau). Khi cầu dài, cân nhắc bẻ cầu.
                    </div>
                  </div>
                  
                  <div class="mb-4">
                    <h4 class="d-flex align-items-center">
                      <span style="width: 28px; height: 28px; color: white; background: var(--primary); border-radius: 50%; display: flex; justify-content: center; align-items: center; margin-right: 8px;">2</span>
                      Chiến thuật bẻ cầu
                    </h4>
                    <div class="py-3 px-4 bg-gray rounded mt-2">
                      Bẻ cầu hiệu quả nhất tại các số Fibonacci (3, 5, 8, 13). Đặc biệt tại 5 và 8, xác suất bẻ cầu rất cao.
                    </div>
                  </div>
                  
                  <div class="mb-4">
                    <h4 class="d-flex align-items-center">
                      <span style="width: 28px; height: 28px; color: white; background: var(--primary); border-radius: 50%; display: flex; justify-content: center; align-items: center; margin-right: 8px;">3</span>
                      Quản lý vốn
                    </h4>
                    <div class="py-3 px-4 bg-gray rounded mt-2">
                      Không đặt quá 5% tổng vốn cho một lượt. Tăng dần mức đặt khi thắng liên tiếp, giảm xuống khi thua.
                    </div>
                  </div>
                  
                  <div class="mb-4">
                    <h4 class="d-flex align-items-center">
                      <span style="width: 28px; height: 28px; color: white; background: var(--primary); border-radius: 50%; display: flex; justify-content: center; align-items: center; margin-right: 8px;">4</span>
                      Dấu hiệu bẻ cầu
                    </h4>
                    <div class="py-3 px-4 bg-gray rounded mt-2">
                      <ul style="padding-left: 1.5rem; margin-bottom: 0;">
                        <li>Cầu kéo dài hơn 5 kết quả giống nhau</li>
                        <li>Cầu đạt đến số Fibonacci (5, 8, 13)</li>
                        <li>Độ tin cậy của dự đoán bẻ cầu trên 70%</li>
                        <li>Phân tích cầu cho thấy điểm bẻ cầu tối ưu</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
    
    <!-- Chart Modal -->
    <div id="chart-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Biểu đồ phân tích</h3>
          <button id="close-modal" class="modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <ul class="tabs mb-5" id="chart-tabs">
            <li class="tab-item active" data-tab="sequence">Chuỗi</li>
            <li class="tab-item" data-tab="markov">Markov</li>
            <li class="tab-item" data-tab="pattern">Mẫu</li>
            <li class="tab-item" data-tab="distribution">Phân phối</li>
            <li class="tab-item" data-tab="heatmap">Heatmap</li>
          </ul>
          
          <div class="chart-container" style="height: 400px;">
            <div id="modal-chart" class="chart"></div>
            <div class="chart-placeholder">Nhập ít nhất 5 kết quả để hiển thị biểu đồ</div>
          </div>
          
          <div class="mt-4">
            <h4>Mô tả biểu đồ:</h4>
            <div id="chart-details" class="py-3 px-4 bg-gray rounded mt-2">Chọn biểu đồ để xem chi tiết phân tích.</div>
          </div>
        </div>
      </div>
    </div>
    
    <footer class="footer">
      <div class="container">
        <div class="py-2">
          &copy; <span id="current-year">2025</span> Tài Xỉu Prediction Tool. All rights reserved.
        </div>
      </div>
    </footer>
  </div>

  <script>
    // Định nghĩa kiểu dữ liệu
    // Giá trị chuỗi: "T" hoặc "X"
    // Các loại tab: "prediction", "patterns", "statistics", "tips", "cauanalysis"
    // Loại biểu đồ: "sequence", "markov", "pattern", "distribution", "heatmap"

    // Lưu trữ trạng thái
    const state = {
      sequence: [],
      activeTab: "prediction",
      chartType: "sequence",
      historyData: [],
      analyzing: false,
      showChartModal: false,
      prediction: null
    };

    /**
     * Phân tích chuỗi và chia thành các đoạn (segments) của cùng giá trị
     */
    function segmentSequence(sequence) {
      if (!sequence.length) return [];
      
      const segments = [];
      let currentValue = sequence[0];
      let currentCount = 1;
      let startIndex = 0;
      
      for (let i = 1; i < sequence.length; i++) {
        if (sequence[i] === currentValue) {
          currentCount++;
        } else {
          segments.push({ value: currentValue, count: currentCount, startIndex });
          currentValue = sequence[i];
          currentCount = 1;
          startIndex = i;
        }
      }
      
      segments.push({ value: currentValue, count: currentCount, startIndex });
      return segments;
    }

    /**
     * Phát hiện mẫu cầu nâng cao - nhận diện nhiều loại mẫu khác nhau
     */
    function detectAdvancedCauPattern(sequence, segments) {
      if (sequence.length < 3) {
        return {
          patternType: "Chưa đủ dữ liệu",
          detectedPatterns: [],
          patternScores: {},
          trend: "early",
          maturity: 0
        };
      }
      
      // Phân tích các loại mẫu
      const patterns = {};
      const detectedPatterns = [];
      
      // Đếm tần suất T và X
      const tCount = sequence.filter(v => v === "T").length;
      const xCount = sequence.filter(v => v === "X").length;
      const total = sequence.length;
      
      // Tính tỉ lệ T:X
      const tRatio = tCount / total;
      const xRatio = xCount / total;
      const ratioDeviation = Math.abs(0.5 - tRatio);
      
      // Kiểm tra tính cân bằng
      if (ratioDeviation < 0.1) {
        patterns["Cân bằng"] = 0.8 - ratioDeviation * 5; // 0.3 ~ 0.8 dựa vào độ lệch
        detectedPatterns.push("Cân bằng");
      } else if (tRatio > 0.65) {
        patterns["Thiên Tài"] = Math.min(0.95, tRatio);
        detectedPatterns.push("Thiên Tài");
      } else if (xRatio > 0.65) {
        patterns["Thiên Xỉu"] = Math.min(0.95, xRatio);
        detectedPatterns.push("Thiên Xỉu");
      }
      
      // Kiểm tra cầu dài
      if (segments.length > 0) {
        const lastSegment = segments[segments.length - 1];
        if (lastSegment.count >= 5) {
          patterns["Cầu dài"] = Math.min(0.9, 0.5 + lastSegment.count * 0.07);
          detectedPatterns.push("Cầu dài");
        } else if (lastSegment.count >= 3) {
          patterns["Cầu trung bình"] = 0.5 + lastSegment.count * 0.05;
          detectedPatterns.push("Cầu trung bình");
        }
      }
      
      // Kiểm tra mẫu xen kẽ T-X-T-X hoặc X-T-X-T
      let alternatingCount = 0;
      for (let i = 1; i < sequence.length; i++) {
        if (sequence[i] !== sequence[i-1]) alternatingCount++;
      }
      
      const alternatingRatio = alternatingCount / (sequence.length - 1);
      if (alternatingRatio > 0.7) {
        patterns["Xen kẽ"] = Math.min(0.9, alternatingRatio);
        detectedPatterns.push("Xen kẽ");
      }
      
      // Kiểm tra mẫu tuần hoàn
      if (sequence.length >= 6) {
        const endSegment = sequence.slice(-3);
        let cyclicScore = 0;
        
        // Kiểm tra các chu kỳ khác nhau
        for (let cycleLength = 2; cycleLength <= 4; cycleLength++) {
          if (sequence.length < cycleLength * 2) continue;
          
          const cycle1 = sequence.slice(-cycleLength * 2, -cycleLength);
          const cycle2 = sequence.slice(-cycleLength);
          
          let matchCount = 0;
          for (let i = 0; i < cycleLength; i++) {
            if (cycle1[i] === cycle2[i]) matchCount++;
          }
          
          const cycleScore = matchCount / cycleLength;
          if (cycleScore > cyclicScore) {
            cyclicScore = cycleScore;
          }
        }
        
        if (cyclicScore > 0.7) {
          patterns["Tuần hoàn"] = cyclicScore;
          detectedPatterns.push("Tuần hoàn");
        }
      }
      
      // Xác định loại mẫu phổ biến nhất
      let mainPattern = "Ngẫu nhiên";
      let highestScore = 0;
      
      Object.entries(patterns).forEach(([pattern, score]) => {
        if (score > highestScore) {
          mainPattern = pattern;
          highestScore = score;
        }
      });
      
      // Xác định xu hướng ổn định
      let trend = "stable";
      if (sequence.length < 8) {
        trend = "early";
      } else {
        const firstHalf = sequence.slice(0, Math.floor(sequence.length / 2));
        const secondHalf = sequence.slice(Math.floor(sequence.length / 2));
        
        const firstHalfTRatio = firstHalf.filter(v => v === "T").length / firstHalf.length;
        const secondHalfTRatio = secondHalf.filter(v => v === "T").length / secondHalf.length;
        
        const trendChange = Math.abs(firstHalfTRatio - secondHalfTRatio);
        
        if (trendChange > 0.25) {
          trend = "transitioning";
        } else if (trendChange > 0.15) {
          trend = "unstable";
        }
      }
      
      // Tính độ trưởng thành của mẫu
      const maturity = Math.min(1, sequence.length / 20);
      
      return {
        patternType: mainPattern,
        detectedPatterns,
        patternScores: patterns,
        trend,
        maturity
      };
    }

    /**
     * Phân tích điểm bẻ cầu chi tiết
     */
    function analyzeEnhancedBreakpoint(sequence, segments) {
      if (sequence.length < 3 || segments.length === 0) {
        return {
          breakProbability: 0.5,
          breakStrength: 0,
          optimalBreakPoint: false,
          fibonacciAlignment: 0
        };
      }
      
      const lastSegment = segments[segments.length - 1];
      
      // Tính xác suất bẻ cầu dựa trên chiều dài đoạn
      let breakProbability = 0.5;
      
      // Các dãy fibonacci: 1, 2, 3, 5, 8, 13...
      const fibonacciNumbers = [1, 2, 3, 5, 8, 13, 21];
      
      // Kiểm tra xem có trùng với số Fibonacci
      const isFibonacciLength = fibonacciNumbers.includes(lastSegment.count);
      
      // Tính độ gần với số Fibonacci
      let closestFibDistance = Math.min(...fibonacciNumbers.map(f => Math.abs(f - lastSegment.count)));
      const fibonacciAlignment = closestFibDistance === 0 ? 1 : 1 / (1 + closestFibDistance);
      
      if (lastSegment.count === 1) {
        // Cầu vừa đổi, khả năng lặp lại cao
        breakProbability = 0.25;
      } else if (lastSegment.count === 2) {
        // Cầu ngắn, chưa ổn định
        breakProbability = 0.35;
      } else if (lastSegment.count === 3) {
        // Cầu bắt đầu ổn định
        breakProbability = 0.47;
      } else if (lastSegment.count === 5) {
        // Fibonacci 5 - điểm bẻ cầu tốt
        breakProbability = 0.75;
      } else if (lastSegment.count === 8) {
        // Fibonacci 8 - điểm bẻ cầu rất tốt
        breakProbability = 0.85;
      } else if (lastSegment.count >= 10) {
        // Cầu quá dài, khả năng bẻ rất cao
        breakProbability = 0.9;
      } else if (isFibonacciLength) {
        // Các số Fibonacci khác
        breakProbability = 0.6 + (lastSegment.count * 0.02);
      } else {
        // Các số không phải Fibonacci
        breakProbability = 0.4 + (lastSegment.count * 0.05);
      }
      
      // Kiểm tra số đoạn trước đó
      if (segments.length >= 2) {
        const previousSegment = segments[segments.length - 2];
        
        // Nếu đoạn trước cũng dài, điều chỉnh xác suất
        if (previousSegment.count >= 5) {
          breakProbability = Math.min(0.95, breakProbability + 0.05);
        }
        
        // Nếu đoạn hiện tại dài hơn đoạn trước, tăng xác suất
        if (lastSegment.count > previousSegment.count) {
          breakProbability = Math.min(0.95, breakProbability + 0.05);
        }
      }
      
      // Phân tích thêm các mẫu lặp lại trong quá khứ
      const uniquePatterns = new Set();
      for (let i = 0; i < segments.length - 1; i++) {
        uniquePatterns.add(`${segments[i].value}-${segments[i].count}`);
      }
      
      // Nếu có nhiều mẫu đa dạng, khả năng bẻ cầu cao hơn
      const patternDiversity = uniquePatterns.size / (segments.length - 1);
      breakProbability = Math.min(0.95, breakProbability + patternDiversity * 0.05);
      
      // Tính độ mạnh của điểm bẻ cầu
      const breakStrength = Math.min(1, lastSegment.count / 10 + fibonacciAlignment * 0.3);
      
      // Xác định điểm bẻ cầu tối ưu
      const optimalBreakPoint = isFibonacciLength && lastSegment.count >= 5;
      
      return {
        breakProbability,
        breakStrength,
        optimalBreakPoint,
        fibonacciAlignment
      };
    }

    /**
     * Phân tích toàn diện cầu
     */
    function performEnhancedCauAnalysis(sequence) {
      if (sequence.length < 3) {
        return {
          prediction: null,
          confidence: 0,
          streakLength: 0,
          breakProbability: 0.5,
          patternType: "Chưa đủ dữ liệu",
          patternTrend: "early",
          detailedAnalysis: {
            oscillationRate: 0,
            streakQuality: 0,
            breakStrength: 0,
            patternStrength: 0,
            optimalBreakPoint: false,
            fibonacciAlignment: 0,
            xingXangIndex: 0,
            adaptability: 0,
            dominantValue: null,
            patternMaturity: 0
          },
          patterns: {
            detectedPatterns: [],
            patternScores: {}
          }
        };
      }
      
      // Phân đoạn chuỗi
      const segments = segmentSequence(sequence);
      
      // Phân tích mẫu cầu
      const patternAnalysis = detectAdvancedCauPattern(sequence, segments);
      
      // Phân tích điểm bẻ cầu
      const breakpointAnalysis = analyzeEnhancedBreakpoint(sequence, segments);
      
      // Lấy thông tin đoạn hiện tại
      const currentSegment = segments[segments.length - 1];
      const currentValue = currentSegment.value;
      const oppositeValue = currentValue === "T" ? "X" : "T";
      
      // Tính tỉ lệ dao động
      let oscillationCount = 0;
      for (let i = 1; i < sequence.length; i++) {
        if (sequence[i] !== sequence[i-1]) {
          oscillationCount++;
        }
      }
      const oscillationRate = oscillationCount / (sequence.length - 1);
      
      // Tính chỉ số xen kẽ
      const xingXangIndex = oscillationRate > 0.7 ? oscillationRate : 
        oscillationRate > 0.5 ? 0.5 + (oscillationRate - 0.5) * 2 : oscillationRate;
      
      // Xác định giá trị chiếm ưu thế
      const tCount = sequence.filter(v => v === "T").length;
      const xCount = sequence.filter(v => v === "X").length;
      let dominantValue = null;
      
      if (tCount > xCount && tCount / sequence.length > 0.6) {
        dominantValue = "T";
      } else if (xCount > tCount && xCount / sequence.length > 0.6) {
        dominantValue = "X";
      }
      
      // Tính độ thích ứng của mẫu
      const adaptability = Math.min(1, patternAnalysis.detectedPatterns.length * 0.2);
      
      // Phân tích để đưa ra dự đoán
      let prediction = null;
      let confidence = 0;
      
      // Logic dự đoán nâng cao
      if (breakpointAnalysis.breakProbability > 0.7 && currentSegment.count >= 3) {
        // Khả năng cao sẽ bẻ cầu
        prediction = oppositeValue;
        confidence = breakpointAnalysis.breakProbability;
      } else if (patternAnalysis.patternType === "Xen kẽ" && patternAnalysis.patternScores["Xen kẽ"] > 0.7) {
        // Mẫu xen kẽ mạnh
        prediction = oppositeValue;
        confidence = patternAnalysis.patternScores["Xen kẽ"];
      } else if (patternAnalysis.patternType === "Tuần hoàn" && patternAnalysis.patternScores["Tuần hoàn"] > 0.7) {
        // Dự đoán dựa trên mẫu tuần hoàn
        // Tìm chu kỳ và dự đoán giá trị tiếp theo
        for (let cycleLength = 2; cycleLength <= 4; cycleLength++) {
          if (sequence.length < cycleLength * 2) continue;
          
          const cycle1 = sequence.slice(-cycleLength * 2, -cycleLength);
          const cycle2 = sequence.slice(-cycleLength);
          
          let matchCount = 0;
          for (let i = 0; i < cycleLength; i++) {
            if (cycle1[i] === cycle2[i]) matchCount++;
          }
          
          const cycleScore = matchCount / cycleLength;
          if (cycleScore > 0.7) {
            // Lấy vị trí tiếp theo trong chu kỳ
            const nextCycleIndex = 0; // Vị trí đầu tiên của chu kỳ mới
            prediction = cycle1[nextCycleIndex];
            confidence = cycleScore;
            break;
          }
        }
      } else if (patternAnalysis.patternType === "Thiên Tài" && patternAnalysis.patternScores["Thiên Tài"] > 0.7) {
        // Xu hướng mạnh thiên về Tài
        prediction = "T";
        confidence = patternAnalysis.patternScores["Thiên Tài"];
      } else if (patternAnalysis.patternType === "Thiên Xỉu" && patternAnalysis.patternScores["Thiên Xỉu"] > 0.7) {
        // Xu hướng mạnh thiên về Xỉu
        prediction = "X";
        confidence = patternAnalysis.patternScores["Thiên Xỉu"];
      } else if (currentSegment.count <= 2) {
        // Cầu ngắn, khả năng tiếp tục cao
        prediction = currentValue;
        confidence = 0.5 + currentSegment.count * 0.05;
      } else {
        // Phân tích tổng hợp khi không có mẫu rõ ràng
        // Ưu tiên theo cầu hiện tại với điều chỉnh dựa vào độ mạnh của mẫu
        prediction = breakpointAnalysis.breakProbability > 0.5 ? oppositeValue : currentValue;
        confidence = Math.abs(breakpointAnalysis.breakProbability - 0.5) * 2;
      }
      
      // Tính chất lượng cầu hiện tại
      const streakQuality = breakpointAnalysis.fibonacciAlignment * 0.5 + 
        (currentSegment.count / 10) * 0.5;
      
      // Tính độ mạnh của mẫu
      const patternStrength = Object.values(patternAnalysis.patternScores).length > 0 
        ? Math.max(...Object.values(patternAnalysis.patternScores))
        : 0;
      
      return {
        prediction,
        confidence: Math.min(0.95, confidence),
        streakLength: currentSegment.count,
        breakProbability: breakpointAnalysis.breakProbability,
        patternType: patternAnalysis.patternType,
        patternTrend: patternAnalysis.trend,
        detailedAnalysis: {
          oscillationRate,
          streakQuality,
          breakStrength: breakpointAnalysis.breakStrength,
          patternStrength,
          optimalBreakPoint: breakpointAnalysis.optimalBreakPoint,
          fibonacciAlignment: breakpointAnalysis.fibonacciAlignment,
          xingXangIndex,
          adaptability,
          dominantValue,
          patternMaturity: patternAnalysis.maturity
        },
        patterns: {
          detectedPatterns: patternAnalysis.detectedPatterns,
          patternScores: patternAnalysis.patternScores
        }
      };
    }

    /**
     * Tính entropy của chuỗi - đo lường sự ngẫu nhiên
     */
    function calculateSequenceEntropy(sequence) {
      if (sequence.length < 2) return 1.0;
      
      // Tính phân phối các cặp kế tiếp
      const pairCounts = {};
      const totalPairs = sequence.length - 1;
      
      for (let i = 0; i < totalPairs; i++) {
        const pair = `${sequence[i]}${sequence[i+1]}`;
        pairCounts[pair] = (pairCounts[pair] || 0) + 1;
      }
      
      // Tính entropy
      let entropy = 0;
      for (const pair in pairCounts) {
        const probability = pairCounts[pair] / totalPairs;
        entropy -= probability * Math.log2(probability);
      }
      
      // Chuẩn hóa về 0-1
      return Math.min(1, entropy / 2);
    }

    /**
     * Phát hiện và đánh giá các mẫu Fibonacci trong chuỗi
     */
    function detectFibonacciPatterns(sequence) {
      if (sequence.length < 3) {
        return { alignmentScore: 0, segments: [] };
      }
      
      // Dãy Fibonacci đầu
      const fibonacciNumbers = [1, 2, 3, 5, 8, 13, 21];
      
      // Phân đoạn chuỗi
      const segments = [];
      let currentValue = sequence[0];
      let currentLength = 1;
      
      for (let i = 1; i < sequence.length; i++) {
        if (sequence[i] === currentValue) {
          currentLength++;
        } else {
          const isFibonacci = fibonacciNumbers.includes(currentLength);
          segments.push({ value: currentValue, length: currentLength, isFibonacci });
          currentValue = sequence[i];
          currentLength = 1;
        }
      }
      
      // Thêm đoạn cuối cùng
      const isFibonacci = fibonacciNumbers.includes(currentLength);
      segments.push({ value: currentValue, length: currentLength, isFibonacci });
      
      // Tính điểm phù hợp với Fibonacci
      const fibSegments = segments.filter(s => s.isFibonacci).length;
      const alignmentScore = segments.length > 0 ? fibSegments / segments.length : 0;
      
      return { alignmentScore, segments };
    }

    /**
     * Dự đoán dựa trên tỉ lệ vàng và các hằng số toán học
     */
    function goldenRatioPrediction(sequence) {
      if (sequence.length < 5) {
        return { prediction: null, confidence: 0 };
      }
      
      // Tỉ lệ vàng phi = 1.618...
      const phi = 1.618033988749895;
      
      // Phân đoạn chuỗi
      let segments = [];
      let currentValue = sequence[0];
      let currentLength = 1;
      
      for (let i = 1; i < sequence.length; i++) {
        if (sequence[i] === currentValue) {
          currentLength++;
        } else {
          segments.push({ value: currentValue, length: currentLength });
          currentValue = sequence[i];
          currentLength = 1;
        }
      }
      
      segments.push({ value: currentValue, length: currentLength });
      
      // Tính độ lệch của các đoạn với bội số của phi
      let totalDeviation = 0;
      let phiAlignedSegments = 0;
      
      segments.forEach(segment => {
        // Tìm bội số gần nhất của phi
        const closestPhiMultiple = Math.round(segment.length / phi) * phi;
        const deviation = Math.abs(segment.length - closestPhiMultiple) / closestPhiMultiple;
        
        if (deviation < 0.2) {
          phiAlignedSegments++;
        }
        
        totalDeviation += deviation;
      });
      
      // Tính điểm phù hợp với tỉ lệ vàng
      const phiAlignmentScore = segments.length > 0 
        ? phiAlignedSegments / segments.length 
        : 0;
      
      // Dự đoán dựa trên đoạn cuối cùng
      const lastSegment = segments[segments.length - 1];
      
      // Tính tỉ lệ đoạn hiện tại so với bội số phi tiếp theo
      const nextPhiMultiple = Math.ceil(lastSegment.length / phi) * phi;
      const currentRatio = lastSegment.length / nextPhiMultiple;
      
      let prediction = null;
      let confidence = 0;
      
      if (currentRatio > 0.8) {
        // Nếu đã gần với bội số phi tiếp theo, khả năng đổi giá trị cao
        prediction = lastSegment.value === "T" ? "X" : "T";
        confidence = Math.min(0.9, 0.5 + phiAlignmentScore * 0.4);
      } else if (phiAlignmentScore > 0.4) {
        // Nếu chuỗi thường phù hợp với tỉ lệ vàng, dự đoán tiếp tục cùng giá trị
        prediction = lastSegment.value;
        confidence = 0.5 + (1 - currentRatio) * 0.3;
      } else {
        // Không có mẫu rõ ràng
        prediction = lastSegment.value; // Giả định tiếp tục giá trị hiện tại
        confidence = 0.5;
      }
      
      return { prediction, confidence };
    }

    /**
     * Mô phỏng neural network cho dự đoán
     */
    function neuralNetworkEmulation(sequence) {
      if (sequence.length < 5) {
        return { prediction: null, confidence: 0 };
      }
      
      // Đặc trưng dùng cho mô hình
      const lastValue = sequence[sequence.length - 1];
      const secondLastValue = sequence.length > 1 ? sequence[sequence.length - 2] : null;
      
      // Tính tỷ lệ T và X
      const tCount = sequence.filter(v => v === "T").length;
      const xCount = sequence.length - tCount;
      
      // Tính trọng số mô hình
      const weightLastValue = 0.4;
      const weightSecondLastValue = 0.2;
      const weightTXRatio = 0.3;
      const weightTrend = 0.1;
      
      // Đếm streak hiện tại
      let currentStreak = 1;
      for (let i = sequence.length - 2; i >= 0; i--) {
        if (sequence[i] === lastValue) {
          currentStreak++;
        } else {
          break;
        }
      }
      
      // Tính xu hướng dựa trên nửa sau của chuỗi
      const halfLength = Math.floor(sequence.length / 2);
      const recentSequence = sequence.slice(-halfLength);
      const recentTCount = recentSequence.filter(v => v === "T").length;
      const recentTRatio = recentTCount / recentSequence.length;
      
      // Điểm cho mỗi giá trị
      let tScore = 0;
      let xScore = 0;
      
      // Trọng số cho giá trị cuối
      if (lastValue === "T") {
        // Nếu giá trị hiện tại là T, điểm cho giá trị tiếp theo
        const streakFactor = Math.min(1, currentStreak / 8); // Streak càng dài, khả năng đổi càng cao
        tScore += weightLastValue * (1 - streakFactor);
        xScore += weightLastValue * streakFactor;
      } else {
        // Nếu giá trị hiện tại là X
        const streakFactor = Math.min(1, currentStreak / 8);
        xScore += weightLastValue * (1 - streakFactor);
        tScore += weightLastValue * streakFactor;
      }
      
      // Trọng số cho giá trị thứ hai
      if (secondLastValue === "T") {
        // Nếu giá trị thứ hai là T, ảnh hưởng đến giá trị tiếp theo
        tScore += weightSecondLastValue * 0.4;
        xScore += weightSecondLastValue * 0.6;
      } else if (secondLastValue === "X") {
        // Nếu giá trị thứ hai là X
        xScore += weightSecondLastValue * 0.4;
        tScore += weightSecondLastValue * 0.6;
      }
      
      // Trọng số cho tỷ lệ T/X
      const tRatio = tCount / sequence.length;
      tScore += weightTXRatio * tRatio;
      xScore += weightTXRatio * (1 - tRatio);
      
      // Trọng số cho xu hướng
      tScore += weightTrend * recentTRatio;
      xScore += weightTrend * (1 - recentTRatio);
      
      // Dự đoán và độ tin cậy
      const prediction = tScore > xScore ? "T" : "X";
      const confidence = Math.abs(tScore - xScore);
      
      return { prediction, confidence: Math.min(0.95, confidence * 2) };
    }

    /**
     * Mô phỏng randomization từ nhiễu lượng tử
     */
    function quantumNoiseModel(sequence) {
      if (sequence.length < 3) {
        return { prediction: null, confidence: 0, noiseLevel: 1 };
      }
      
      // Tính entropy làm chỉ số nhiễu
      const entropy = calculateSequenceEntropy(sequence);
      
      // Mức độ nhiễu lượng tử (giả lập) - càng cao càng ngẫu nhiên
      const quantumNoiseLevel = entropy;
      
      // Tính tần suất xuất hiện T/X
      const tCount = sequence.filter(v => v === "T").length;
      const tRatio = tCount / sequence.length;
      
      // Yếu tố nhiễu ảnh hưởng đến dự đoán
      let prediction;
      let confidence;
      
      if (quantumNoiseLevel > 0.7) {
        // Nhiễu cao, gần như ngẫu nhiên hoàn toàn
        prediction = Math.random() < 0.5 ? "T" : "X";
        confidence = 0.5 + (Math.random() * 0.1); // 0.5-0.6
      } else {
        // Nhiễu thấp, dùng tỉ lệ T/X để dự đoán
        const randomFactor = Math.random() * 0.2; // 0-0.2
        
        if (tRatio > 0.55) {
          // Thiên về T
          prediction = Math.random() < 0.3 ? "X" : "T";
          confidence = 0.5 + (tRatio - 0.5) + randomFactor;
        } else if (tRatio < 0.45) {
          // Thiên về X
          prediction = Math.random() < 0.3 ? "T" : "X";
          confidence = 0.5 + (0.5 - tRatio) + randomFactor;
        } else {
          // Cân bằng
          prediction = Math.random() < 0.5 ? "T" : "X";
          confidence = 0.5 + randomFactor;
        }
      }
      
      return {
        prediction,
        confidence: Math.min(0.75, confidence), // Giới hạn confidence của mô hình này
        noiseLevel: quantumNoiseLevel
      };
    }

    /**
     * Thuật toán tổng hợp - kết hợp kết quả từ nhiều mô hình
     */
    function getUltraPrecisePrediction(sequence) {
      if (sequence.length < 5) {
        return { prediction: null, confidence: 0 };
      }
      
      // Thu thập dự đoán từ các mô hình khác nhau
      const neuralPrediction = neuralNetworkEmulation(sequence);
      const goldenRatioPrediction2 = goldenRatioPrediction(sequence);
      const quantumPrediction = quantumNoiseModel(sequence);
      const cauAnalysis = performEnhancedCauAnalysis(sequence);
      
      // Kết hợp dự đoán với trọng số
      const predictions = [
        { 
          model: 'neural', 
          prediction: neuralPrediction.prediction, 
          confidence: neuralPrediction.confidence,
          weight: 0.25
        },
        { 
          model: 'goldenRatio', 
          prediction: goldenRatioPrediction2.prediction, 
          confidence: goldenRatioPrediction2.confidence,
          weight: 0.15
        },
        { 
          model: 'quantum', 
          prediction: quantumPrediction.prediction, 
          confidence: quantumPrediction.confidence,
          weight: 0.1
        },
        {
          model: 'cauAnalysis',
          prediction: cauAnalysis.prediction,
          confidence: cauAnalysis.confidence,
          weight: 0.5
        }
      ];
      
      // Thống kê dự đoán
      const tVotes = predictions
        .filter(p => p.prediction === "T")
        .reduce((sum, p) => sum + p.confidence * p.weight, 0);
        
      const xVotes = predictions
        .filter(p => p.prediction === "X")
        .reduce((sum, p) => sum + p.confidence * p.weight, 0);
      
      // Quyết định dự đoán cuối cùng
      let finalPrediction = null;
      let finalConfidence = 0;
      
      if (tVotes > xVotes) {
        finalPrediction = "T";
        finalConfidence = Math.min(0.95, 0.5 + ((tVotes - xVotes) / (tVotes + xVotes)) * 0.5);
      } else if (xVotes > tVotes) {
        finalPrediction = "X";
        finalConfidence = Math.min(0.95, 0.5 + ((xVotes - tVotes) / (tVotes + xVotes)) * 0.5);
      }
      
      // Điều chỉnh dựa vào entropy
      const entropy = calculateSequenceEntropy(sequence);
      if (entropy > 0.8) {
        // Chuỗi rất ngẫu nhiên, giảm độ tin cậy
        finalConfidence = Math.max(0.5, finalConfidence * 0.8);
      }
      
      return {
        prediction: finalPrediction,
        confidence: finalConfidence
      };
    }

    // Format percentage
    function formatPercent(value) {
      return `${Math.round(value * 100)}%`;
    }

    // Update prediction display
    function updatePredictionDisplay() {
      const predictionValue = document.getElementById('prediction-value');
      const confidenceValue = document.getElementById('confidence-value');
      const confidenceBar = document.getElementById('confidence-bar');
      const loadingIndicator = document.getElementById('loading-indicator');
      
      // Hide loading indicator
      if (loadingIndicator) {
        loadingIndicator.style.display = 'none';
      }
      
      if (!state.prediction || state.prediction.prediction === null) {
        predictionValue.textContent = '--';
        predictionValue.className = 'prediction-result';
        confidenceValue.textContent = '--';
        confidenceBar.style.width = '0%';
        return;
      }
      
      predictionValue.textContent = state.prediction.prediction === 'T' ? 'TÀI' : 'XỈU';
      
      // Apply class for color styling
      predictionValue.className = 'prediction-result ' + (state.prediction.prediction === 'T' ? 'tai' : 'xiu');
      
      confidenceValue.textContent = formatPercent(state.prediction.confidence);
      confidenceBar.style.width = formatPercent(state.prediction.confidence);
    }

    // Update sequence display
    function updateSequenceDisplay() {
      const display = document.getElementById('sequence-display');
      display.innerHTML = '';
      
      state.sequence.forEach(value => {
        const item = document.createElement('div');
        item.className = `sequence-item ${value}`;
        item.textContent = value;
        display.appendChild(item);
      });
    }

    // Update stats display
    function updateStats() {
      const total = state.sequence.length;
      const taiCount = state.sequence.filter(v => v === 'T').length;
      const xiuCount = state.sequence.filter(v => v === 'X').length;
      
      document.getElementById('stat-total').textContent = total;
      document.getElementById('stat-tai-count').textContent = taiCount;
      document.getElementById('stat-xiu-count').textContent = xiuCount;
      
      if (total > 0) {
        document.getElementById('stat-tai-ratio').textContent = formatPercent(taiCount / total);
        document.getElementById('stat-xiu-ratio').textContent = formatPercent(xiuCount / total);
        
        // Calculate current streak
        let currentStreak = 1;
        const lastValue = state.sequence[state.sequence.length - 1];
        for (let i = state.sequence.length - 2; i >= 0; i--) {
          if (state.sequence[i] === lastValue) {
            currentStreak++;
          } else {
            break;
          }
        }
        document.getElementById('stat-current-streak').textContent = currentStreak;
        
        // Calculate longest streak
        const segments = segmentSequence(state.sequence);
        const longestStreak = segments.reduce((max, segment) => Math.max(max, segment.count), 0);
        document.getElementById('stat-longest-streak').textContent = longestStreak;
        
        // Calculate prediction accuracy if we have history
        if (state.historyData.length > 0) {
          const predictionsWithResult = state.historyData.filter(item => 
            item.prediction && item.prediction.prediction !== null
          );
          
          if (predictionsWithResult.length > 0) {
            const successfulPredictions = predictionsWithResult.filter(item => item.wasSuccessful).length;
            const accuracy = successfulPredictions / predictionsWithResult.length;
            document.getElementById('stat-accuracy').textContent = formatPercent(accuracy);
          } else {
            document.getElementById('stat-accuracy').textContent = '--';
          }
        } else {
          document.getElementById('stat-accuracy').textContent = '--';
        }
      } else {
        document.getElementById('stat-tai-ratio').textContent = '--';
        document.getElementById('stat-xiu-ratio').textContent = '--';
        document.getElementById('stat-current-streak').textContent = '0';
        document.getElementById('stat-longest-streak').textContent = '0';
        document.getElementById('stat-accuracy').textContent = '--';
      }
    }

    // Update cau analysis display
    function updateCauAnalysis() {
      const cauDetails = document.getElementById('cau-details');
      const breakpointDetails = document.getElementById('breakpoint-details');
      
      if (state.sequence.length < 3) {
        cauDetails.textContent = 'Chưa có đủ dữ liệu để phân tích cầu.';
        breakpointDetails.textContent = 'Chưa có đủ dữ liệu để phân tích bẻ cầu.';
        return;
      }
      
      const analysisResult = performEnhancedCauAnalysis(state.sequence);
      
      // Update cau details
      cauDetails.innerHTML = `
        <div class="mb-2"><strong>Loại mẫu:</strong> ${analysisResult.patternType}</div>
        <div class="mb-2"><strong>Chiều dài cầu hiện tại:</strong> ${analysisResult.streakLength}</div>
        <div class="mb-2"><strong>Xu hướng:</strong> ${
          analysisResult.patternTrend === 'stable' ? 'Ổn định' : 
          analysisResult.patternTrend === 'unstable' ? 'Không ổn định' : 
          analysisResult.patternTrend === 'transitioning' ? 'Đang chuyển đổi' : 'Mới hình thành'
        }</div>
        <div><strong>Mẫu đã phát hiện:</strong> ${
          analysisResult.patterns.detectedPatterns.length > 0 
            ? analysisResult.patterns.detectedPatterns.join(', ') 
            : 'Chưa phát hiện mẫu rõ ràng'
        }</div>
      `;
      
      // Update breakpoint details
      breakpointDetails.innerHTML = `
        <div class="mb-2"><strong>Xác suất bẻ cầu:</strong> <span style="color: var(--primary); font-weight: 600;">${formatPercent(analysisResult.breakProbability)}</span></div>
        <div class="mb-2"><strong>Độ mạnh bẻ cầu:</strong> ${formatPercent(analysisResult.detailedAnalysis.breakStrength)}</div>
        <div class="mb-2"><strong>Điểm bẻ cầu tối ưu:</strong> ${
          analysisResult.detailedAnalysis.optimalBreakPoint 
            ? '<span style="color: var(--primary); font-weight: 600;">Có</span>' 
            : 'Không'
        }</div>
        <div class="mb-2"><strong>Giá trị chiếm ưu thế:</strong> ${
          analysisResult.detailedAnalysis.dominantValue === 'T' ? 'Tài' : 
          analysisResult.detailedAnalysis.dominantValue === 'X' ? 'Xỉu' : 'Không có'
        }</div>
        <div><strong>Độ phù hợp Fibonacci:</strong> ${formatPercent(analysisResult.detailedAnalysis.fibonacciAlignment)}</div>
      `;
    }

    // Update pattern analysis
    function updatePatternAnalysis() {
      const patternDescription = document.getElementById('pattern-description');
      const recommendationText = document.getElementById('recommendation-text');
      
      if (state.sequence.length < 5) {
        patternDescription.textContent = 'Chưa có đủ dữ liệu để phân tích mẫu. Cần ít nhất 5 kết quả.';
        recommendationText.textContent = 'Chưa có đủ dữ liệu để đưa ra khuyến nghị.';
        return;
      }
      
      const segments = segmentSequence(state.sequence);
      const patternAnalysis = detectAdvancedCauPattern(state.sequence, segments);
      
      // Pattern description
      let description = `<div class="mb-2"><strong>Mẫu chính:</strong> ${patternAnalysis.patternType}</div>`;
      
      if (patternAnalysis.detectedPatterns.length > 0) {
        description += `<div class="mb-2"><strong>Các mẫu phát hiện:</strong></div><ul style="list-style: none; padding-left: 0.5rem;">`;
        patternAnalysis.detectedPatterns.forEach(pattern => {
          const score = patternAnalysis.patternScores[pattern];
          description += `<li class="mb-1">• ${pattern} <span style="font-weight: 600;">(độ mạnh: ${formatPercent(score)})</span></li>`;
        });
        description += '</ul>';
      }
      
      // Additional statistics
      const tCount = state.sequence.filter(v => v === 'T').length;
      const xCount = state.sequence.filter(v => v === 'X').length;
      const tRatio = tCount / state.sequence.length;
      
      description += `
        <div class="mb-2 mt-3"><strong>Tỷ lệ Tài/Xỉu:</strong> ${formatPercent(tRatio)} / ${formatPercent(1-tRatio)}</div>
        <div><strong>Độ trưởng thành của mẫu:</strong> ${formatPercent(patternAnalysis.maturity)}</div>
      `;
      
      patternDescription.innerHTML = description;
      
      // Recommendation
      let recommendation = '';
      
      if (patternAnalysis.patternType === 'Cầu dài') {
        recommendation = `Cầu đang chạy tương đối dài. <strong>Cân nhắc việc bẻ cầu</strong> khi đạt đến số Fibonacci tiếp theo (3, 5, 8, 13).`;
      } else if (patternAnalysis.patternType === 'Xen kẽ') {
        recommendation = `Mẫu xen kẽ rõ ràng. <strong>Nên đặt ngược với kết quả gần nhất</strong>.`;
      } else if (patternAnalysis.patternType === 'Tuần hoàn') {
        recommendation = `Mẫu tuần hoàn đang xuất hiện. <strong>Dự đoán dựa trên chu kỳ đã phát hiện</strong>.`;
      } else if (patternAnalysis.patternType === 'Thiên Tài') {
        recommendation = `Chuỗi đang thiên về Tài. <strong>Nên đặt theo Tài</strong> nhưng chú ý các dấu hiệu bẻ cầu.`;
      } else if (patternAnalysis.patternType === 'Thiên Xỉu') {
        recommendation = `Chuỗi đang thiên về Xỉu. <strong>Nên đặt theo Xỉu</strong> nhưng chú ý các dấu hiệu bẻ cầu.`;
      } else if (patternAnalysis.patternType === 'Cân bằng') {
        recommendation = `Chuỗi khá cân bằng giữa Tài và Xỉu. <strong>Nên tập trung vào việc phát hiện các mẫu ngắn</strong>.`;
      } else {
        recommendation = `Chưa phát hiện mẫu rõ ràng. <strong>Dựa vào thuật toán dự đoán chính</strong> và cẩn thận với việc đặt cược.`;
      }
      
      recommendationText.innerHTML = recommendation;
    }

    // Analyze the sequence
    function analyzeSequence() {
      if (state.sequence.length < 3) {
        state.prediction = { prediction: null, confidence: 0 };
        updatePredictionDisplay();
        return;
      }

      state.analyzing = true;
      
      // Show loading indicator
      const loadingIndicator = document.getElementById('loading-indicator');
      if (loadingIndicator) {
        loadingIndicator.style.display = 'inline-block';
      }
      
      // Simulate a slight delay for analysis
      setTimeout(() => {
        try {
          // Use our prediction algorithms
          const cauAnalysis = performEnhancedCauAnalysis(state.sequence);
          const advancedPrediction = getUltraPrecisePrediction(state.sequence);
          
          // Combine the results with higher weight on the advanced predictor
          const combinedPrediction = 
            advancedPrediction.confidence > cauAnalysis.confidence 
              ? advancedPrediction 
              : cauAnalysis;
              
          state.prediction = combinedPrediction;
          
          // Update displays
          updatePredictionDisplay();
          updateCauAnalysis();
          updatePatternAnalysis();
        } catch (error) {
          console.error("Error analyzing sequence:", error);
          state.prediction = { prediction: null, confidence: 0 };
          updatePredictionDisplay();
        } finally {
          state.analyzing = false;
        }
      }, 500);
    }

    // Add a value to the sequence
    function addToSequence(value) {
      state.sequence.push(value);
      
      // Update history with new entry
      const wasBreakAttempt = state.prediction !== null && 
        state.prediction.prediction !== null && 
        state.prediction.prediction !== value;
      
      const wasSuccessful = state.prediction !== null && 
        state.prediction.prediction !== null && 
        state.prediction.prediction === value;
      
      const historyItem = {
        timestamp: new Date(),
        sequence: [...state.sequence],
        prediction: state.prediction || { prediction: null, confidence: 0 },
        wasBreakAttempt,
        wasSuccessful
      };
      
      state.historyData.push(historyItem);
      
      // Update UI
      updateSequenceDisplay();
      updateStats();
      
      // Automatically analyze after adding to sequence
      analyzeSequence();
      
      // Save to localStorage
      saveToLocalStorage();
    }

    // Delete the last result
    function deleteLastResult() {
      if (state.sequence.length > 0) {
        state.sequence.pop();
        state.historyData.pop();
        
        // Update UI
        updateSequenceDisplay();
        updateStats();
        
        // Re-analyze
        analyzeSequence();
        
        // Save to localStorage
        saveToLocalStorage();
      }
    }

    // Clear all results
    function clearAllResults() {
      state.sequence = [];
      state.historyData = [];
      state.prediction = null;
      
      // Update UI
      updateSequenceDisplay();
      updateStats();
      updatePredictionDisplay();
      updateCauAnalysis();
      updatePatternAnalysis();
      
      // Save to localStorage
      saveToLocalStorage();
    }

    // Toggle chart modal
    function toggleChartModal() {
      state.showChartModal = !state.showChartModal;
      const modal = document.getElementById('chart-modal');
      
      if (state.showChartModal) {
        modal.classList.add('show');
      } else {
        modal.classList.remove('show');
      }
    }

    // Switch tabs
    function switchTab(tabId) {
      state.activeTab = tabId;
      
      // Update active tab in UI
      const tabItems = document.querySelectorAll('#analysis-tabs .tab-item');
      const tabContents = document.querySelectorAll('.tab-content');
      
      tabItems.forEach(item => {
        if (item.getAttribute('data-tab') === tabId) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
      
      tabContents.forEach(content => {
        if (content.id === `tab-${tabId}`) {
          content.classList.add('active');
        } else {
          content.classList.remove('active');
        }
      });
      
      // If switching to cau analysis, update the display
      if (tabId === 'cauanalysis') {
        updateCauAnalysis();
      } else if (tabId === 'patterns') {
        updatePatternAnalysis();
      }
    }

    // Switch chart type
    function switchChartType(chartType) {
      state.chartType = chartType;
      
      // Update active chart tab in modal
      const chartTabs = document.querySelectorAll('#chart-tabs .tab-item');
      chartTabs.forEach(item => {
        if (item.getAttribute('data-tab') === chartType) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
      
      // Update chart description
      const chartDetails = document.getElementById('chart-details');
      
      switch (chartType) {
        case 'sequence':
          chartDetails.textContent = 'Biểu đồ chuỗi hiển thị toàn bộ chuỗi kết quả theo thời gian.';
          break;
        case 'markov':
          chartDetails.textContent = 'Biểu đồ Markov hiển thị xác suất chuyển đổi giữa các trạng thái Tài/Xỉu.';
          break;
        case 'pattern':
          chartDetails.textContent = 'Biểu đồ mẫu hiển thị các mẫu lặp lại đã phát hiện trong chuỗi.';
          break;
        case 'distribution':
          chartDetails.textContent = 'Biểu đồ phân phối hiển thị tỷ lệ xuất hiện của Tài/Xỉu.';
          break;
        case 'heatmap':
          chartDetails.textContent = 'Biểu đồ heatmap hiển thị mật độ xuất hiện của các kết quả theo thời gian.';
          break;
        default:
          chartDetails.textContent = 'Chọn biểu đồ để xem chi tiết phân tích.';
      }
    }

    // Save to localStorage
    function saveToLocalStorage() {
      try {
        const dataToSave = {
          sequence: state.sequence,
          historyData: state.historyData
        };
        localStorage.setItem('taixiuPredictionData', JSON.stringify(dataToSave));
      } catch (error) {
        console.error("Error saving data:", error);
      }
    }

    // Load from localStorage
    function loadFromLocalStorage() {
      try {
        console.log("Đang tải dữ liệu từ localStorage...");
        const savedData = localStorage.getItem('taixiuPredictionData');
        
        if (!savedData) {
          console.log("Không tìm thấy dữ liệu trong localStorage");
          return;
        }
        
        const parsedData = JSON.parse(savedData);
        
        // Restore dates from strings
        const historyWithDates = parsedData.historyData.map(item => ({
          ...item,
          timestamp: new Date(item.timestamp)
        }));
        
        state.sequence = parsedData.sequence;
        state.historyData = historyWithDates;
        
        // Update UI
        updateSequenceDisplay();
        updateStats();
        
        // Re-analyze the loaded sequence
        analyzeSequence();
      } catch (error) {
        console.error("Error loading data:", error);
      }
    }

    // Initialize the app
    function initApp() {
      // Set current year in footer
      document.getElementById('current-year').textContent = new Date().getFullYear();
      
      // Attach event listeners
      document.getElementById('tai-btn').addEventListener('click', () => addToSequence('T'));
      document.getElementById('xiu-btn').addEventListener('click', () => addToSequence('X'));
      document.getElementById('delete-last').addEventListener('click', deleteLastResult);
      document.getElementById('clear-all').addEventListener('click', clearAllResults);
      document.getElementById('show-chart-modal').addEventListener('click', toggleChartModal);
      document.getElementById('close-modal').addEventListener('click', toggleChartModal);
      
      // Tab switching
      document.querySelectorAll('#analysis-tabs .tab-item').forEach(tab => {
        tab.addEventListener('click', () => {
          switchTab(tab.getAttribute('data-tab'));
        });
      });
      
      // Chart type switching
      document.querySelectorAll('#chart-tabs .tab-item').forEach(tab => {
        tab.addEventListener('click', () => {
          switchChartType(tab.getAttribute('data-tab'));
        });
      });
      
      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.key === 't' || e.key === 'T') {
          addToSequence('T');
        } else if (e.key === 'x' || e.key === 'X') {
          addToSequence('X');
        } else if (e.key === 'Backspace' || e.key === 'Delete') {
          deleteLastResult();
        } else if (e.key === 'Escape') {
          if (state.showChartModal) {
            toggleChartModal();
          }
        }
      });
      
      // Add click event to close modal when clicking outside
      const modal = document.getElementById('chart-modal');
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          toggleChartModal();
        }
      });
      
      // Load saved data
      loadFromLocalStorage();
    }

    // Initialize when the page is loaded
    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
